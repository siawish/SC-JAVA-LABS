LAB 06: Open-Ended - Advanced Object-Oriented System Design & Data Management Lab Title: Advanced Object-Oriented System Design & Data Management Total Marks: 6 Submission Deadline: 21-10-2025 1. Introduction This open-ended lab challenges you to design and implement a sophisticated banking system using Java. You will be required to leverage advanced concepts of Object-Oriented Programming (OOP), complex data structures, and intricate control flow to create a robust, scalable, and user-friendly application. The primary emphasis is on architectural design, managing diverse data types, implementing detailed transaction logging, and handling various scenarios gracefully through robust error management. This exercise is designed to significantly enhance your critical thinking, problem decomposition, and comprehensive software design abilities. 2. Learning Objectives Upon successful completion of this lab, students should be able to: • Design and implement a multi-layered OOP system with clear responsibilities, demonstrating strong cohesion and loose coupling between classes. • Model real-world entities accurately through appropriate class hierarchies (inheritance) and relationships (composition, aggregation). • Select and implement complex data structures (e.g., HashMap, ArrayList of custom objects) for efficient storage, retrieval, and management of various data types. • Implement robust error handling and validation mechanisms, including custom exceptions, for both user input and business logic. • Utilize advanced loop and iterator patterns for effective data processing, searching, and display. • Demonstrate advanced critical thinking in breaking down a complex, real-world problem into manageable, interconnected modules. • Develop flexible and extensible code that can accommodate future feature enhancements and modifications with minimal impact. 3. Task 1: Comprehensive ATM & Bank System Design and Implementation (4 Marks) Design and implement a complete Java-based banking system that includes a user-facing ATM interface and a robust backend "Bank" component. Your system must support multiple customers, diverse account types, and meticulous transaction logging. 3.1. Core Functional Requirements: 1. Customer Management: o Implement a Customer class encapsulating unique customer identifiers, names, and a collection of all BankAccount objects associated with that customer. o The Bank system must be capable of managing multiple Customer objects. 2. Diverse Bank Accounts: o Design an abstract class BankAccount defining common properties (e.g., account number, balance, customer ID) and abstract behaviors (e.g., deposit(amount), withdraw(amount), getBalance()). o Create at least two concrete subclasses extending BankAccount, each implementing its specific business rules: ▪ SavingsAccount: Must enforce a minimum balance requirement. (You may optionally implement a simplified interest calculation, e.g., a fixed percentage added periodically). ▪ CheckingAccount: Must support an overdraft limit, allowing the balance to become negative up to a predefined threshold. (You may optionally implement transaction fees for certain operations). o Ensure that each account type correctly enforces its specific rules during deposit and withdraw operations. 3. Transaction History and Logging: o Develop a Transaction class that records comprehensive details of every financial operation, including: transaction ID, type (e.g., DEPOSIT, WITHDRAWAL, TRANSFER), amount, date/time, affected account(s), and final status (e.g., SUCCESS, FAILED_INSUFFICIENT_FUNDS, FAILED_INVALID_ACCOUNT). o Each BankAccount instance must maintain an ArrayList to store its complete transaction history. o Customers must be able to view a chronological list of their transactions for a selected account. 4. Enhanced ATM Functionality: o Secure Login Mechanism: ▪ Users must authenticate using an ATM card number (or customer ID) and a PIN. ▪ Implement a security feature to block a customer's access (e.g., temporarily disable ATM access) after N (e.g., 3) consecutive incorrect PIN attempts. The nature of the block (temporary/permanent) should be documented in your design. o Account Selection: After successful login, if a customer possesses multiple accounts (e.g., both SavingsAccount and CheckingAccount), they must be presented with options to select the specific account for their desired transaction. o Core ATM Operations: ▪ Check Balance: Display the current balance for the selected account. ▪ Deposit Funds: Add funds to the selected account. ▪ Withdraw Funds: Withdraw funds from the selected account, strictly adhering to account-specific rules (e.g., minimum balance for SavingsAccount, overdraft limits for CheckingAccount). ▪ View Transaction History: Display the transaction log for the selected account. ▪ Print Receipt: For every successful transaction, a simple text-based receipt should be generated and displayed, including relevant details such as transaction ID, type, amount, and the new account balance. 5. Bank Backend Simulation: o Create a Bank class that serves as the central data repository and orchestrator for all Customer and BankAccount objects within the system. o The Bank class must be responsible for: ▪ Registering new customers and creating new accounts. ▪ Providing methods for efficient retrieval of Customer or BankAccount objects by their unique identifiers. ▪ Initializing the system with a predefined set of sample customers and their accounts upon startup. o The ATM class should interact solely with the Bank class to perform operations, thereby abstracting the underlying data management. 3.2. Design Considerations & Hints: • Class Relationships: Carefully consider and define the relationships between your classes (e.g., Bank aggregates Customers, Customer aggregates BankAccounts, BankAccount aggregates Tran sactions, ATM interacts with Bank). • Data Structures: Choose appropriate data structures for optimal performance and data integrity. HashMap in Bank (key: customer ID), ArrayList within Customer, and HashMap in Bank (key: account number) for fast account lookup are strong candidates. • Error Handling: Implement robust error handling using try-catch blocks for input validation and custom exceptions (e.g., InsufficientFundsException, InvalidAccountException, AccountBlockedException) for business logic failures. • Polymorphism: Leverage polymorphism by defining common methods in BankAccount and overriding them in subclasses, allowing the ATM or Bank to interact with BankAccount objects generically. • Enums: Consider using enum types for TransactionType (DEPOSIT, WITHDRAWAL, TRANSFER) and AccountStatus (ACTIVE, BLOCKED, CLOSED) for improved readability and type safety. • Date/Time: Utilize the java.time package for accurate transaction timestamps. • User Interface: Implement a clear, intuitive text-based, menu-driven interface using System.out.println() for output and java.util.Scanner for user input. 3.3. Deliverables for Task 1: • Complete Java Source Code: All .java files that constitute your banking system. • Detailed Design Document (embedded as Javadoc comments or in a separate DESIGN.md text file): o UML-like Class Diagram (text-based representation): Clearly illustrate the main classes, their key attributes, significant methods, and the relationships between them (e.g., composition, inheritance). o Data Structure Justification: Provide a rationale for your choice of data structures for managing customers, accounts, and transactions, explaining why each was selected. o Inheritance and Polymorphism Explanation: Describe how you employed inheritance for different BankAccount types and how polymorphism facilitates interactions within your ATM or Bank operations. o Error Handling Strategy: Detail your approach to input validation and business logic error handling, including any custom exceptions you created. 4. Task 2: Advanced Feature - Funds Transfer & Bank Administration (2 Marks) Extend your existing banking system from Task 1 with more complex functionalities and introduce a separate administrative interface. 4.1. Extension Requirements: 1. Inter-Account Funds Transfer (within the same customer): o Allow a logged-in customer to transfer funds between their own associated SavingsAccount and CheckingAccount. This requires a precise selection of both the source and destination accounts. 2. Cross-Customer Funds Transfer (within the same bank): o Enable a logged-in customer to initiate a funds transfer to another customer's account within the same simulated bank. o The user must input the destination account number and the transfer amount. o Implement rigorous validation: the destination account must exist and be active, and the source account must have sufficient funds. 3. Basic Bank Administrator Interface: o Implement a distinct, simple text-based interface for a BankAdministrator. o Admin Login: A simple, hardcoded administrator username and password (e.g., "admin"/"password") is acceptable for this lab. o Admin Functions: ▪ View All Customers: Display a list of all registered customers, including their customer IDs and associated account numbers. ▪ View All Accounts: List all bank accounts managed by the bank, showing their type, account number, customer ID, and current balance. ▪ Create New Account: The administrator should be able to create a new SavingsAccount or CheckingAccount for an existing Customer. ▪ Unblock Account: Provide a function for the administrator to unblock a customer's account that was previously blocked due to incorrect PIN attempts. 4.2. Design Considerations & Hints: • Security Context: Clearly differentiate between customer (ATM) and administrator login flows and available functionalities. • Code Refactoring: As new features are added, actively look for opportunities to refactor common logic into reusable helper methods or new, specialized classes to maintain code cleanliness and avoid duplication. • Modularity: Ensure that the administrative functionalities are clearly separated and distinct from the customer-facing ATM functionalities. • Efficiency: Optimize data retrieval for admin queries and transfer operations, especially when searching for accounts across multiple customers. 4.3. Deliverables for Task 2: • Updated Java Source Code: All .java files, incorporating the new features and any necessary refactorings. • Explanation of New Features (embedded as Javadoc comments or in the DESIGN.md file): o Clearly describe the implementation logic for both intra-customer and cross-customer funds transfers. o Detail the functionalities provided by the Bank Administrator interface and explain how it interacts with the Bank object to perform its operations. 5. Assessment Criteria The following criteria will be used to evaluate your submission: • Architectural Design & OOP Principles (30%): o Quality of class design, clear responsibilities, and effective relationships. o Appropriate use of inheritance, polymorphism, encapsulation, and modularization. o How well the system accurately models real-world banking entities and processes. • Correctness & Robustness (30%): o Complete adherence to all specified functional requirements for both tasks. o Comprehensive and graceful error handling for both user input and business logic failures. o System stability and predictable behavior under various valid, invalid, and edge-case scenarios. • Data Management & Collections (15%): o Effective and efficient selection and implementation of appropriate data structures for storing and managing diverse types of information (customers, accounts, transactions). • Code Quality (15%): o Readability, clarity, consistency, and maintainability of the code. o Meaningful variable, method, and class naming conventions. o Adequate and informative comments (especially Javadoc comments for classes and public methods). o Adherence to standard Java coding practices. • Critical Thinking & Problem Solving (10%): o Evidence of advanced problem decomposition and strategic planning. o Demonstration of thoughtful design choices and creative solutions to complex challenges. o The overall elegance and efficiency of the implemented solution.